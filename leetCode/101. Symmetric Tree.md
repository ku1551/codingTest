# 101. Symmetric Tree
## Source

[leetcode 101](https://leetcode.com/problems/symmetric-tree/description/?envType=problem-list-v2&envId=depth-first-search)

## Apporach

1. dfs를 통해서 값을 깊게 파면서 값을 찾아간다. 
2. 두개의 값을 비교한다. 왼쪽과 오른쪽 거울 값을 통해서 값을 찾아간다.

## Code
    /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode() {}
    *     TreeNode(int val) { this.val = val; }
    *     TreeNode(int val, TreeNode left, TreeNode right) {
    *         this.val = val;
    *         this.left = left;
    *         this.right = right;
    *     }
    * }
    */
    class Solution {
        public boolean isSymmetric(TreeNode root) {
            return isMirror(root.left, root.right);
        }

        private boolean isMirror(TreeNode n1, TreeNode n2){
            if(n1 == null && n2 == null){
                return true;
            }

            if(n1 == null || n2 == null){
                return false;
            }

            return n1.val == n2.val && isMirror(n1.left, n2.right) && isMirror(n1.right , n2.left);
        }
    }

